{"version":3,"file":"static/js/170.44ac927d.chunk.js","mappings":"2KAwEIA,EACF,SAAsBC,GACpBC,KAAKC,aAAe,GACpBD,KAAKE,SAAUC,EAAAA,EAAAA,MACfH,KAAKI,iBAAkBD,EAAAA,EAAAA,MACvBH,KAAKD,aAAeA,CACtB,EAYF,IAAIM,EAAW,CACbC,YAAa,SAAUC,EAAaC,EAAQN,EAASE,GACnD,IAAIK,EAAaF,EAAYG,uBAAuB,QAASC,EAAAA,IAAkBC,OAAO,GAClFC,EAAaN,EAAYG,uBAAuB,QAASC,EAAAA,IAAkBC,OAAO,GAStFJ,EAAOP,aAAe,CAAC,IAAK,KAC5BC,EAAQY,IAAI,IAAKL,GACjBP,EAAQY,IAAI,IAAKD,GACbE,EAAWN,KACbL,EAAgBU,IAAI,IAAKL,GACzBD,EAAOQ,sBAAwB,GAE7BD,EAAWF,KACbT,EAAgBU,IAAI,IAAKD,GACO,MAAhCL,EAAOQ,wBAAkCR,EAAOQ,sBAAwB,GAE5E,EACAC,WAAY,SAAUV,EAAaC,EAAQN,EAASE,GAClD,IAAIc,EAAkBX,EAAYG,uBAAuB,aAAcC,EAAAA,IAAkBC,OAAO,GAMhGJ,EAAOP,aAAe,CAAC,UACvBC,EAAQY,IAAI,SAAUI,GAClBH,EAAWG,KACbd,EAAgBU,IAAI,SAAUI,GAC9BV,EAAOQ,sBAAwB,EAEnC,EACAG,MAAO,SAAUZ,EAAaC,EAAQN,EAASE,GAC7C,IAAIgB,EAAab,EAAYG,uBAAuB,QAASC,EAAAA,IAAkBC,OAAO,GAClFS,EAAkBD,EAAWE,cAAc,cAC3CC,EAAiBH,EAAWE,cAAc,aAS9Cd,EAAOP,aAAe,CAAC,SAAU,SACjCC,EAAQY,IAAI,SAAUO,GACtBnB,EAAQY,IAAI,QAASS,GACjBR,EAAWM,KACbjB,EAAgBU,IAAI,SAAUO,GAC9Bb,EAAOQ,sBAAwB,GAE7BD,EAAWQ,KACbnB,EAAgBU,IAAI,QAASS,GACG,MAAhCf,EAAOQ,wBAAkCR,EAAOQ,sBAAwB,GAE5E,EACAQ,IAAK,SAAUjB,EAAaC,EAAQN,EAASE,GAC3CI,EAAOP,aAAe,CAAC,MAAO,MAChC,EACAwB,SAAU,SAAUlB,EAAaC,EAAQN,EAASE,GAChD,IAAIsB,EAAUnB,EAAYmB,QACtBC,EAAgBD,EAAQE,aAAa,WAAYrB,EAAYsB,IAAI,kBACjE5B,EAAeO,EAAOP,aAAe0B,EAAcG,WAAWC,SAClEC,EAAAA,EAAAA,IAAKL,EAAcM,mBAAmB,SAAUC,EAAWC,GACzD,IAAIC,EAAYV,EAAQE,aAAa,eAAgBM,GACjDG,EAAUpC,EAAakC,GAC3BjC,EAAQY,IAAIuB,EAASD,GACjBrB,EAAWqB,KACbhC,EAAgBU,IAAIuB,EAASD,GACO,MAAhC5B,EAAOQ,wBACTR,EAAOQ,sBAAwBmB,GAGrC,GACF,GAEF,SAASpB,EAAWqB,GAClB,MAAiC,aAA1BA,EAAUP,IAAI,OACvB,C,4CCbA,QAxDA,SAA0BS,EAAW/B,EAAagC,GAChDA,EAAMA,GAAO,CAAC,EACd,IACIC,EADAC,EAAgBlC,EAAYmC,mBAE5BC,GAAmB,EACnBL,GACFK,GAAmB,EACnBH,GAASI,EAAAA,EAAAA,IAAiCN,IAI1CK,GAFAH,EAASC,EAAcI,aAEGC,eAAiBC,EAAAA,GAE7C,IAAIC,EDrCC,SAAiCzC,GACtC,IAAIR,EAAeQ,EAAYsB,IAAI,oBAC/BrB,EAAS,IAAIV,EAAaC,GAC1BkD,EAAQ5C,EAASN,GACrB,GAAIkD,EAEF,OADAA,EAAM1C,EAAaC,EAAQA,EAAON,QAASM,EAAOJ,iBAC3CI,CAEX,CC6BqB0C,CAAwB3C,GACvC4C,EAjEN,SAA4B5C,EAAayC,GACvC,IAEIG,EAFApD,EAAeQ,EAAYsB,IAAI,oBAC/BuB,EAAqBC,EAAAA,EAAiBxB,IAAI9B,GAmB9C,OAjBIiD,GAAgBA,EAAa/C,eAC/BkD,EAAkBG,EAAAA,GAAWN,EAAa/C,cAAc,SAAUsD,GAChE,IAAIC,EAAU,CACZC,KAAMF,GAEJnB,EAAYY,EAAa9C,QAAQ2B,IAAI0B,GACzC,GAAInB,EAAW,CACb,IAAIsB,EAAWtB,EAAUP,IAAI,QAC7B2B,EAAQG,MAAOC,EAAAA,EAAAA,GAAuBF,EACxC,CACA,OAAOF,CACT,KAEGL,IAEHA,EAAkBC,IAAuBA,EAAmBS,kBAAoBT,EAAmBS,oBAAsBT,EAAmBtB,WAAWC,UAAY,CAAC,IAAK,MAEpKoB,CACT,CA2CwBW,CAAmBvD,EAAayC,GAClDe,EAAqBxB,EAAIwB,mBACzBC,EAAkBV,EAAAA,GAAkBS,GAAsBA,EAAqBA,EAAqBT,EAAAA,GAAaW,EAAAA,GAAiCd,EAAiB5C,GAAe,KAClL2D,EAAyB,CAC3BC,gBAAiBhB,EACjBiB,cAAe7B,EAAI6B,cACnBC,aAAc9D,EAAY+D,YAC1BN,gBAAiBA,EACjBO,yBAA0B5B,GAExB6B,GAASC,EAAAA,EAAAA,GAAwBjC,EAAQ0B,GACzClD,EArDN,SAA2B0D,EAAaC,EAAuB3B,GAC7D,IAAIhC,EACA4D,EAoBJ,OAnBA5B,GAAgBM,EAAAA,GAAYoB,GAAa,SAAUlB,EAASqB,GAC1D,IAAIC,EAAWtB,EAAQsB,SACnBC,EAAoB/B,EAAa5C,gBAAgByB,IAAIiD,GACrDC,IAC2B,MAAzB/D,IACFA,EAAwB6D,GAE1BrB,EAAQwB,YAAcD,EAAkBE,iBACpCN,IACFnB,EAAQmB,uBAAwB,IAGF,MAA9BnB,EAAQ0B,UAAUC,WACpBP,GAAgB,EAEpB,IACKA,GAA0C,MAAzB5D,IACpB0D,EAAY1D,GAAuBkE,UAAUC,SAAW,GAEnDnE,CACT,CA8B8BoE,CAAkBZ,EAAO1C,WAAYS,EAAIoC,sBAAuB3B,GACxFqC,EAAS1C,EAA8D,KAA3CF,EAAc6C,mBAAmBd,GAC7De,GAAuBC,EAAAA,EAAAA,IAAgBjF,EAAa,CACtDiE,OAAQA,EACRa,MAAOA,IAELI,EAAO,IAAIC,EAAAA,EAAWlB,EAAQjE,GAClCkF,EAAKE,mBAAmBJ,GACxB,IAAIK,EAA0C,MAAzB5E,GAUvB,SAAmCwB,GACjC,GAAIA,EAAOM,eAAiBC,EAAAA,GAAwB,CAClD,IAAI8C,EAIR,SAA0BC,GACxB,IAAIC,EAAI,EACR,KAAOA,EAAID,EAAIE,QAAoB,MAAVF,EAAIC,IAC3BA,IAEF,OAAOD,EAAIC,EACb,CAVqBE,CAAiBzD,EAAOiD,MAAQ,IACjD,OAAQnC,EAAAA,IAAe4C,EAAAA,EAAAA,IAAiBL,GAC1C,CACF,CAfwDM,CAA0B3D,GAAU,SAAU4D,EAASC,EAASC,EAAWzB,GAE/H,OAAOA,IAAa7D,EAAwBsF,EAAYtG,KAAKuG,sBAAsBH,EAASC,EAASC,EAAWzB,EAClH,EAAI,KAKJ,OAJAY,EAAKe,eAAgB,EACrBf,EAAKgB,SAEL9D,EAAmBH,EAAS6C,EAAO,KAAMO,GAClCH,CACT,C,6EClFO,SAASD,EAAgBjF,EAAamG,EAAiBnE,GAE5D,IAEIoE,EACAnC,EACAa,EAJAuB,GADJrE,EAAMA,GAAO,CAAC,GACIqE,QACdC,EAAwBtE,EAAIsE,uBAoGlC,SAAiCH,GAC/B,QAAQI,EAAAA,EAAAA,IAAmBJ,EAAgBlC,OAC7C,CAlGMuC,CAAwBL,IAG1BlC,EAASkC,EAAgBlC,OACzBmC,EAAsBnC,EAAO1C,WAC7BuD,EAAQqB,EAAgBrB,OAJxBsB,EAAsBD,EAOxB,IACIM,EACAC,EACAC,EACAC,EAJAC,KAAc7G,IAAeA,EAAYsB,IAAI,UA8BjD,IAzBAG,EAAAA,EAAAA,IAAK2E,GAAqB,SAAUU,EAAelF,IAC7CmF,EAAAA,EAAAA,IAASD,KACXV,EAAoBxE,GAASkF,EAAgB,CAC3C5D,KAAM4D,IAGND,IAAaC,EAAcE,eAExBX,GAAYI,IAAoBK,EAAcrC,cACjDgC,EAAmBK,GAGhBJ,GAAyC,YAAvBI,EAAc1D,MAA6C,SAAvB0D,EAAc1D,MAAqBkD,GAAyBA,IAA0BQ,EAAcvC,WAC7JmC,EAAiBI,GAGvB,KACIJ,GAAmBL,GAAYI,IAGjCJ,GAAU,GAKRK,EAAgB,CAIlBC,EAAuB,qBAAuB3G,EAAYiH,GAC1DL,EAAuB,qBAAuB5G,EAAYiH,GAEtDR,IACFA,EAAiBrC,uBAAwB,GAE3C,IAAI8C,EAAuBR,EAAenC,SACtC4C,EAAiBT,EAAetD,KAChCgE,EAAyB,GAC7B3F,EAAAA,EAAAA,IAAK2E,GAAqB,SAAUU,GAC9BA,EAAcvC,WAAa2C,GAC7BE,GAEJ,IACA,IAAIC,EAA6B,CAC/BnE,KAAMyD,EACNpC,SAAU2C,EACVI,cAAeF,EACfhE,KAAM+D,EACNH,cAAc,EACdO,oBAAoB,EACpBC,cAAepB,EAAoBX,QAEjCgC,EAA6B,CAC/BvE,KAAM0D,EAGNrC,SAAUqC,EACVU,cAAeF,EAAyB,EACxChE,KAAM+D,EACNH,cAAc,EACdO,oBAAoB,EACpBC,cAAepB,EAAoBX,OAAS,GAE1CxB,GACEa,IACFuC,EAA2BG,cAAgB1C,EAAM4C,2BAA2Bd,EAAsBO,GAClGM,EAA2BD,cAAgB1C,EAAM4C,2BAA2Bf,EAAsBQ,IAEpGlD,EAAO0D,2BAA2BN,GAClCpD,EAAO0D,2BAA2BF,KAElCrB,EAAoBwB,KAAKP,GACzBjB,EAAoBwB,KAAKH,GAE7B,CACA,MAAO,CACLI,iBAAkBnB,GAAkBA,EAAexD,KACnD4E,mBAAoBrB,GAAoBA,EAAiBvD,KACzD6E,iBAAkB1B,EAClBO,qBAAsBA,EACtBD,qBAAsBA,EAE1B,CAIO,SAASqB,EAAmB9C,EAAM+C,GAGvC,QAASA,GAAcA,IAAe/C,EAAKgD,mBAAmB,mBAChE,CACO,SAASC,EAAoBjD,EAAMkD,GACxC,OAAOJ,EAAmB9C,EAAMkD,GAAalD,EAAKgD,mBAAmB,wBAA0BE,CACjG,C","sources":["../node_modules/echarts/lib/model/referHelper.js","../node_modules/echarts/lib/chart/helper/createSeriesData.js","../node_modules/echarts/lib/data/helper/dataStackHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\n/**\r\n * Helper for model references.\r\n * There are many manners to refer axis/coordSys.\r\n */\n// TODO\n// merge relevant logic to this file?\n// check: \"modelHelper\" of tooltip and \"BrushTargetManager\".\nimport { createHashMap, retrieve, each } from 'zrender/lib/core/util.js';\nimport { SINGLE_REFERRING } from '../util/model.js';\n/**\r\n * @class\r\n * For example:\r\n * {\r\n *     coordSysName: 'cartesian2d',\r\n *     coordSysDims: ['x', 'y', ...],\r\n *     axisMap: HashMap({\r\n *         x: xAxisModel,\r\n *         y: yAxisModel\r\n *     }),\r\n *     categoryAxisMap: HashMap({\r\n *         x: xAxisModel,\r\n *         y: undefined\r\n *     }),\r\n *     // The index of the first category axis in `coordSysDims`.\r\n *     // `null/undefined` means no category axis exists.\r\n *     firstCategoryDimIndex: 1,\r\n *     // To replace user specified encode.\r\n * }\r\n */\nvar CoordSysInfo = /** @class */function () {\n  function CoordSysInfo(coordSysName) {\n    this.coordSysDims = [];\n    this.axisMap = createHashMap();\n    this.categoryAxisMap = createHashMap();\n    this.coordSysName = coordSysName;\n  }\n  return CoordSysInfo;\n}();\nexport function getCoordSysInfoBySeries(seriesModel) {\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var result = new CoordSysInfo(coordSysName);\n  var fetch = fetchers[coordSysName];\n  if (fetch) {\n    fetch(seriesModel, result, result.axisMap, result.categoryAxisMap);\n    return result;\n  }\n}\nvar fetchers = {\n  cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var xAxisModel = seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0];\n    var yAxisModel = seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!xAxisModel) {\n        throw new Error('xAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '\" not found');\n      }\n      if (!yAxisModel) {\n        throw new Error('yAxis \"' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '\" not found');\n      }\n    }\n    result.coordSysDims = ['x', 'y'];\n    axisMap.set('x', xAxisModel);\n    axisMap.set('y', yAxisModel);\n    if (isCategory(xAxisModel)) {\n      categoryAxisMap.set('x', xAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(yAxisModel)) {\n      categoryAxisMap.set('y', yAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0];\n    if (process.env.NODE_ENV !== 'production') {\n      if (!singleAxisModel) {\n        throw new Error('singleAxis should be specified.');\n      }\n    }\n    result.coordSysDims = ['single'];\n    axisMap.set('single', singleAxisModel);\n    if (isCategory(singleAxisModel)) {\n      categoryAxisMap.set('single', singleAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n  },\n  polar: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0];\n    var radiusAxisModel = polarModel.findAxisModel('radiusAxis');\n    var angleAxisModel = polarModel.findAxisModel('angleAxis');\n    if (process.env.NODE_ENV !== 'production') {\n      if (!angleAxisModel) {\n        throw new Error('angleAxis option not found');\n      }\n      if (!radiusAxisModel) {\n        throw new Error('radiusAxis option not found');\n      }\n    }\n    result.coordSysDims = ['radius', 'angle'];\n    axisMap.set('radius', radiusAxisModel);\n    axisMap.set('angle', angleAxisModel);\n    if (isCategory(radiusAxisModel)) {\n      categoryAxisMap.set('radius', radiusAxisModel);\n      result.firstCategoryDimIndex = 0;\n    }\n    if (isCategory(angleAxisModel)) {\n      categoryAxisMap.set('angle', angleAxisModel);\n      result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1);\n    }\n  },\n  geo: function (seriesModel, result, axisMap, categoryAxisMap) {\n    result.coordSysDims = ['lng', 'lat'];\n  },\n  parallel: function (seriesModel, result, axisMap, categoryAxisMap) {\n    var ecModel = seriesModel.ecModel;\n    var parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'));\n    var coordSysDims = result.coordSysDims = parallelModel.dimensions.slice();\n    each(parallelModel.parallelAxisIndex, function (axisIndex, index) {\n      var axisModel = ecModel.getComponent('parallelAxis', axisIndex);\n      var axisDim = coordSysDims[index];\n      axisMap.set(axisDim, axisModel);\n      if (isCategory(axisModel)) {\n        categoryAxisMap.set(axisDim, axisModel);\n        if (result.firstCategoryDimIndex == null) {\n          result.firstCategoryDimIndex = index;\n        }\n      }\n    });\n  }\n};\nfunction isCategory(axisModel) {\n  return axisModel.get('type') === 'category';\n}","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport * as zrUtil from 'zrender/lib/core/util.js';\nimport SeriesData from '../../data/SeriesData.js';\nimport prepareSeriesDataSchema from '../../data/helper/createDimensions.js';\nimport { getDimensionTypeByAxis } from '../../data/helper/dimensionHelper.js';\nimport { getDataItemValue } from '../../util/model.js';\nimport CoordinateSystem from '../../core/CoordinateSystem.js';\nimport { getCoordSysInfoBySeries } from '../../model/referHelper.js';\nimport { createSourceFromSeriesDataOption } from '../../data/Source.js';\nimport { enableDataStack } from '../../data/helper/dataStackHelper.js';\nimport { makeSeriesEncodeForAxisCoordSys } from '../../data/helper/sourceHelper.js';\nimport { SOURCE_FORMAT_ORIGINAL } from '../../util/types.js';\nfunction getCoordSysDimDefs(seriesModel, coordSysInfo) {\n  var coordSysName = seriesModel.get('coordinateSystem');\n  var registeredCoordSys = CoordinateSystem.get(coordSysName);\n  var coordSysDimDefs;\n  if (coordSysInfo && coordSysInfo.coordSysDims) {\n    coordSysDimDefs = zrUtil.map(coordSysInfo.coordSysDims, function (dim) {\n      var dimInfo = {\n        name: dim\n      };\n      var axisModel = coordSysInfo.axisMap.get(dim);\n      if (axisModel) {\n        var axisType = axisModel.get('type');\n        dimInfo.type = getDimensionTypeByAxis(axisType);\n      }\n      return dimInfo;\n    });\n  }\n  if (!coordSysDimDefs) {\n    // Get dimensions from registered coordinate system\n    coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y'];\n  }\n  return coordSysDimDefs;\n}\nfunction injectOrdinalMeta(dimInfoList, createInvertedIndices, coordSysInfo) {\n  var firstCategoryDimIndex;\n  var hasNameEncode;\n  coordSysInfo && zrUtil.each(dimInfoList, function (dimInfo, dimIndex) {\n    var coordDim = dimInfo.coordDim;\n    var categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim);\n    if (categoryAxisModel) {\n      if (firstCategoryDimIndex == null) {\n        firstCategoryDimIndex = dimIndex;\n      }\n      dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta();\n      if (createInvertedIndices) {\n        dimInfo.createInvertedIndices = true;\n      }\n    }\n    if (dimInfo.otherDims.itemName != null) {\n      hasNameEncode = true;\n    }\n  });\n  if (!hasNameEncode && firstCategoryDimIndex != null) {\n    dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0;\n  }\n  return firstCategoryDimIndex;\n}\n/**\r\n * Caution: there are side effects to `sourceManager` in this method.\r\n * Should better only be called in `Series['getInitialData']`.\r\n */\nfunction createSeriesData(sourceRaw, seriesModel, opt) {\n  opt = opt || {};\n  var sourceManager = seriesModel.getSourceManager();\n  var source;\n  var isOriginalSource = false;\n  if (sourceRaw) {\n    isOriginalSource = true;\n    source = createSourceFromSeriesDataOption(sourceRaw);\n  } else {\n    source = sourceManager.getSource();\n    // Is series.data. not dataset.\n    isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL;\n  }\n  var coordSysInfo = getCoordSysInfoBySeries(seriesModel);\n  var coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo);\n  var useEncodeDefaulter = opt.useEncodeDefaulter;\n  var encodeDefaulter = zrUtil.isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? zrUtil.curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null;\n  var createDimensionOptions = {\n    coordDimensions: coordSysDimDefs,\n    generateCoord: opt.generateCoord,\n    encodeDefine: seriesModel.getEncode(),\n    encodeDefaulter: encodeDefaulter,\n    canOmitUnusedDimensions: !isOriginalSource\n  };\n  var schema = prepareSeriesDataSchema(source, createDimensionOptions);\n  var firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo);\n  var store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null;\n  var stackCalculationInfo = enableDataStack(seriesModel, {\n    schema: schema,\n    store: store\n  });\n  var data = new SeriesData(schema, seriesModel);\n  data.setCalculationInfo(stackCalculationInfo);\n  var dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {\n    // Use dataIndex as ordinal value in categoryAxis\n    return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex);\n  } : null;\n  data.hasItemOption = false;\n  data.initData(\n  // Try to reuse the data store in sourceManager if using dataset.\n  isOriginalSource ? source : store, null, dimValueGetter);\n  return data;\n}\nfunction isNeedCompleteOrdinalData(source) {\n  if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var sampleItem = firstDataNotNull(source.data || []);\n    return !zrUtil.isArray(getDataItemValue(sampleItem));\n  }\n}\nfunction firstDataNotNull(arr) {\n  var i = 0;\n  while (i < arr.length && arr[i] == null) {\n    i++;\n  }\n  return arr[i];\n}\nexport default createSeriesData;","\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\r\n* Licensed to the Apache Software Foundation (ASF) under one\r\n* or more contributor license agreements.  See the NOTICE file\r\n* distributed with this work for additional information\r\n* regarding copyright ownership.  The ASF licenses this file\r\n* to you under the Apache License, Version 2.0 (the\r\n* \"License\"); you may not use this file except in compliance\r\n* with the License.  You may obtain a copy of the License at\r\n*\r\n*   http://www.apache.org/licenses/LICENSE-2.0\r\n*\r\n* Unless required by applicable law or agreed to in writing,\r\n* software distributed under the License is distributed on an\r\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\n* KIND, either express or implied.  See the License for the\r\n* specific language governing permissions and limitations\r\n* under the License.\r\n*/\nimport { each, isString } from 'zrender/lib/core/util.js';\nimport { isSeriesDataSchema } from './SeriesDataSchema.js';\n/**\r\n * Note that it is too complicated to support 3d stack by value\r\n * (have to create two-dimension inverted index), so in 3d case\r\n * we just support that stacked by index.\r\n *\r\n * @param seriesModel\r\n * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.\r\n *        The input will be modified.\r\n * @param opt\r\n * @param opt.stackedCoordDimension Specify a coord dimension if needed.\r\n * @param opt.byIndex=false\r\n * @return calculationInfo\r\n * {\r\n *     stackedDimension: string\r\n *     stackedByDimension: string\r\n *     isStackedByIndex: boolean\r\n *     stackedOverDimension: string\r\n *     stackResultDimension: string\r\n * }\r\n */\nexport function enableDataStack(seriesModel, dimensionsInput, opt) {\n  opt = opt || {};\n  var byIndex = opt.byIndex;\n  var stackedCoordDimension = opt.stackedCoordDimension;\n  var dimensionDefineList;\n  var schema;\n  var store;\n  if (isLegacyDimensionsInput(dimensionsInput)) {\n    dimensionDefineList = dimensionsInput;\n  } else {\n    schema = dimensionsInput.schema;\n    dimensionDefineList = schema.dimensions;\n    store = dimensionsInput.store;\n  }\n  // Compatibal: when `stack` is set as '', do not stack.\n  var mayStack = !!(seriesModel && seriesModel.get('stack'));\n  var stackedByDimInfo;\n  var stackedDimInfo;\n  var stackResultDimension;\n  var stackedOverDimension;\n  each(dimensionDefineList, function (dimensionInfo, index) {\n    if (isString(dimensionInfo)) {\n      dimensionDefineList[index] = dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    if (mayStack && !dimensionInfo.isExtraCoord) {\n      // Find the first ordinal dimension as the stackedByDimInfo.\n      if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {\n        stackedByDimInfo = dimensionInfo;\n      }\n      // Find the first stackable dimension as the stackedDimInfo.\n      if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {\n        stackedDimInfo = dimensionInfo;\n      }\n    }\n  });\n  if (stackedDimInfo && !byIndex && !stackedByDimInfo) {\n    // Compatible with previous design, value axis (time axis) only stack by index.\n    // It may make sense if the user provides elaborately constructed data.\n    byIndex = true;\n  }\n  // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.\n  // That put stack logic in List is for using conveniently in echarts extensions, but it\n  // might not be a good way.\n  if (stackedDimInfo) {\n    // Use a weird name that not duplicated with other names.\n    // Also need to use seriesModel.id as postfix because different\n    // series may share same data store. The stack dimension needs to be distinguished.\n    stackResultDimension = '__\\0ecstackresult_' + seriesModel.id;\n    stackedOverDimension = '__\\0ecstackedover_' + seriesModel.id;\n    // Create inverted index to fast query index by value.\n    if (stackedByDimInfo) {\n      stackedByDimInfo.createInvertedIndices = true;\n    }\n    var stackedDimCoordDim_1 = stackedDimInfo.coordDim;\n    var stackedDimType = stackedDimInfo.type;\n    var stackedDimCoordIndex_1 = 0;\n    each(dimensionDefineList, function (dimensionInfo) {\n      if (dimensionInfo.coordDim === stackedDimCoordDim_1) {\n        stackedDimCoordIndex_1++;\n      }\n    });\n    var stackedOverDimensionDefine = {\n      name: stackResultDimension,\n      coordDim: stackedDimCoordDim_1,\n      coordDimIndex: stackedDimCoordIndex_1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length\n    };\n    var stackResultDimensionDefine = {\n      name: stackedOverDimension,\n      // This dimension contains stack base (generally, 0), so do not set it as\n      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.\n      coordDim: stackedOverDimension,\n      coordDimIndex: stackedDimCoordIndex_1 + 1,\n      type: stackedDimType,\n      isExtraCoord: true,\n      isCalculationCoord: true,\n      storeDimIndex: dimensionDefineList.length + 1\n    };\n    if (schema) {\n      if (store) {\n        stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType);\n        stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType);\n      }\n      schema.appendCalculationDimension(stackedOverDimensionDefine);\n      schema.appendCalculationDimension(stackResultDimensionDefine);\n    } else {\n      dimensionDefineList.push(stackedOverDimensionDefine);\n      dimensionDefineList.push(stackResultDimensionDefine);\n    }\n  }\n  return {\n    stackedDimension: stackedDimInfo && stackedDimInfo.name,\n    stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,\n    isStackedByIndex: byIndex,\n    stackedOverDimension: stackedOverDimension,\n    stackResultDimension: stackResultDimension\n  };\n}\nfunction isLegacyDimensionsInput(dimensionsInput) {\n  return !isSeriesDataSchema(dimensionsInput.schema);\n}\nexport function isDimensionStacked(data, stackedDim) {\n  // Each single series only maps to one pair of axis. So we do not need to\n  // check stackByDim, whatever stacked by a dimension or stacked by index.\n  return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension');\n}\nexport function getStackedDimension(data, targetDim) {\n  return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim;\n}"],"names":["CoordSysInfo","coordSysName","this","coordSysDims","axisMap","createHashMap","categoryAxisMap","fetchers","cartesian2d","seriesModel","result","xAxisModel","getReferringComponents","SINGLE_REFERRING","models","yAxisModel","set","isCategory","firstCategoryDimIndex","singleAxis","singleAxisModel","polar","polarModel","radiusAxisModel","findAxisModel","angleAxisModel","geo","parallel","ecModel","parallelModel","getComponent","get","dimensions","slice","each","parallelAxisIndex","axisIndex","index","axisModel","axisDim","sourceRaw","opt","source","sourceManager","getSourceManager","isOriginalSource","createSourceFromSeriesDataOption","getSource","sourceFormat","SOURCE_FORMAT_ORIGINAL","coordSysInfo","fetch","getCoordSysInfoBySeries","coordSysDimDefs","registeredCoordSys","CoordinateSystem","zrUtil","dim","dimInfo","name","axisType","type","getDimensionTypeByAxis","getDimensionsInfo","getCoordSysDimDefs","useEncodeDefaulter","encodeDefaulter","makeSeriesEncodeForAxisCoordSys","createDimensionOptions","coordDimensions","generateCoord","encodeDefine","getEncode","canOmitUnusedDimensions","schema","prepareSeriesDataSchema","dimInfoList","createInvertedIndices","hasNameEncode","dimIndex","coordDim","categoryAxisModel","ordinalMeta","getOrdinalMeta","otherDims","itemName","injectOrdinalMeta","store","getSharedDataStore","stackCalculationInfo","enableDataStack","data","SeriesData","setCalculationInfo","dimValueGetter","sampleItem","arr","i","length","firstDataNotNull","getDataItemValue","isNeedCompleteOrdinalData","itemOpt","dimName","dataIndex","defaultDimValueGetter","hasItemOption","initData","dimensionsInput","dimensionDefineList","byIndex","stackedCoordDimension","isSeriesDataSchema","isLegacyDimensionsInput","stackedByDimInfo","stackedDimInfo","stackResultDimension","stackedOverDimension","mayStack","dimensionInfo","isString","isExtraCoord","id","stackedDimCoordDim_1","stackedDimType","stackedDimCoordIndex_1","stackedOverDimensionDefine","coordDimIndex","isCalculationCoord","storeDimIndex","stackResultDimensionDefine","ensureCalculationDimension","appendCalculationDimension","push","stackedDimension","stackedByDimension","isStackedByIndex","isDimensionStacked","stackedDim","getCalculationInfo","getStackedDimension","targetDim"],"sourceRoot":""}